pacman(8) -- 软件包管理器
==============================

##语法

`pacman <命令> [选项] [软件包名称]`

##描述

pacman是linux系统上的用于记录安装的软件包信息的管理器.它的主要特点有:支
持依赖、软件包组、安装卸载关联以及与远程服务器同步信息和更新系统.pacman
的软件包格式是".tar.gz"的压缩格式.

3.0.0版以来,pacman一直是linkman:libalpm(即”Arch Linux软件包管理“函数库)
的前端.这个函数库支持不同写法的前端(例如,它支持图形化前端).

##命令

* `-Q,--query`:
查询软件包数据库.运用这条命令你不仅可以查看已安装软件包以及所含
文件的信息,还可以查看独立软件包的元信息(meta-information)(包括软
件包的依赖,冲突,安装日期,创建日期,大小).这条命令可已对本机的软件
包数据库执行,也可以对独立的.tar.gz包执行.具体参看下面的查询选项.

* `-R, --remove`:
从系统中移除某个软件包.该命令也可以对软件包组执行,执行后,软件包
组内所有的软件包都会被移除.属于指定软件包的文件会被删除,而后软件
包数据库会执行更新.除非加上"--nosave"(不保存)选项,移除软件包的配
置文件都会以.pacsave的后缀保存.具体参看下面的移除选项.

* `-S, --sync`:
同步软件包.软件包是从远程服务器上直接下载安装的,与之一同安装的还
有运行软件所需的所有依赖.例如,"pacman -S qt"会下载并安装qt及qt的
所有依赖.如果同一名称的软件包存在于不同源中,可以指定源:"pacman
-S testing/qt".同样也可以给定版本要求:`pacman -S "bash>=3.2"`(引
号是必需的,否则设shell会将“>”理解为重定向).可以指定软件包,也可以
指定软件包组.例如,如果gnome是一个已定义的软件包组,那么执行
"pacman -S gnome"就会将gnome组中所有的软件包安装,当然也会安装这
些软件包的依赖.pacman也可以处理一些具有相同或相近作用的软件包.例
如,执行"pacman -S foo",pacman首先会搜索名为foo的软件包.如果没有
找到的话,pacman就会搜索一些具有相同或相近作用的软件包.如果找到了
具有相同或相近作用的软件包,这些软件包就会被安装.你也可以用
"pacman -Su"来升级本机上所有陈旧的软件包升级是这样进行的:pacman
先将本机上的软件包同远程服务器上的软件包进行版本对比.版本对比是
按照如下规则进行的:

字母顺序:1.0a<1.0alpha<1.0b<1.0beta<1.0p<1.0pre<1.0rc<1.0
数字顺序:1<1.0<1.1<1.1.1<1.2<2.0<3.0.0

* `-U, --update`:
升级软件包,或安装软件包.可以给定一个URL网址,也可以给定一个文件路
径.升级的过程是一个“移除,然后安装”的过程.想知道pacman如何处理配
置文件,请查看处理配置文件

* `-V, --version`:
显示版本,然后退出.

* `-h, --help`:
显示给定命令的句法.如果没有给定命令,显示的将是全部命令的句法.

##通用选项

* `--asdeps`:
模糊安装软件包;换句话说,就是假定该软件包安装的原因是由于依赖.在
使用makepkg以及其他从源代码编译的工具时,需要在编译一个软件包之前
安装该软件包的依赖,这时候,这个命令选项就十分有用了.

* `--asexplicit`:
精确安装软件;换句话说,就是假定该软件包安装的原因是精确安装.如果
想把一个依赖标记成精确安装,使它不会在执行带--recursive(递归)的移
除命令时删除,这时候,这个命令选项就十分有用了.

* `-b, --dbpath <路径>`:
指定另外的数据库位置;默认为/var/lib/pacman,路径为绝对路径. 

* `-d, --nodeps`:
略过所有依赖关系检查

* `-f, --force`:
强制安装,覆盖存在冲突的文件(谨慎使用);

* `-r, --root <路径>`:
指定其他的根路径;用于向暂时挂载的其他系统根路径安装软件.  
* `-v, --verbose`:
输出路径,例如根路径,配置文件,数据库,缓存的路径等.

* `--cachedir <dir>`:
指定其他缓存路径;默认为/var/cache/pacman/pkg,路径为绝对路径.

* `--config <路径>`:
指定另外的配置文件

* `--logfile <路径>`:
指定另外的日志文件

* `--noconfirm`:
不询问确认

* `--noprogressbar`:
下载文件时不显示进度条

* `--noscriptlet`:
不执行安装脚本集(谨慎使用);

##查询选项

* `-c, --changelog`:
查看某软件包的更新日志

* `-d, --deps`:
列出所有作为依赖关系安装的软件包

* `-e, --explicit`:
列出所有单独指定安装的软件包

* `-g,--groups`:
查看某软件包组所属的所有软件包

* `-i, --info `:
查看软件包信息(-ii 查看备份文件)

* `-l, --list`:
列出被查询软件包的内容

* `-m, --foreign `:
列出没有在同步数据库时找到的已安装软件包

* `-o, --owns <文件> `:
查询哪个软件包拥有<文件>

* `-p, --file <软件包>`:
从某个软件包而不是数据库查询

* `-q, --quiet `:
在查询或搜索时显示较少的信息

* `-s, --search <regex>`:
搜寻符合指定字符串的已安装本地的软件包

* `-t, --unrequired`:
列出所有不被其他软件包要求的软件包

* `-u, --upgrades`:
列出所有可升级的软件包

* `-p,--file`:
在命令行标记软件包为文件,而不是数据库信息条目,在与--info和--list
搭配时有用.

##移除选项

* `-c, --cascade`:
删除软件包及所有的依赖于此的软件包

* `-k, --dbonly`:
只删除数据库记录,不删除文件

* `-n, --nosave`:
同时删除配置文件

* `-s, --recursive`:
同时删除(不会破坏其他软件包的)依赖关系,"-ss"也包括单独指定安装的
依赖关系

* `-u, --unneeded`:
同时删除不需要的(且不会破坏其他软件包的)依赖关系

##同步选项

* `-c, --clean`:
从缓存目录中删除旧软件包(-cc清除所有)

* `-g, --groups`:
查看某软件包组所属的所有软件包

* `-i, --info`:
查看软件包信息

* `-l, --list <软件仓库>`:
查看在该软件仓库中的软件包清单

* `-q, --quiet`:
在查询或搜索时显示较少的信息

* `-p, --print-uris`:
打印指定软件包及依赖关系中的URI

* `-s, --search <regex表达式>`:
按照指定字符串查询远端软件仓库

* `-u, --sysupgrade`:
升级所有过期软件包

* `-w, --downloadonly`:
下载但不安装/升级软件包

* `-y, --refresh`:
从服务器下载新的软件包数据库

* `--needed`:
不重新安装已经为最新的软件包

* `--ignore <软件包>`:
升级时忽略某个软件包(可多次使用)

* `--ignoregroup <软件包组>`:
升级时忽略某个软件包组(可多次使用)
  
##配置文件处理

pacman同rpm在处理已标记为备份的文件的逻辑上时是一样.更新系统时,pacman用
3个md5检测工具检测标记为备份的文件,以决定将要执行的命令:一个检测已安装的
原始文件,一个检测将要安装的新文件,一个检测实际存在与文件系统上的当前文件
.对比这3个检测的结果之后,会有如下情形:

	x x x(顺序依次为原始文件,当前文件,新文件)
	所有文件一致,所以覆盖不会有什么影响.安装软件包.

	x x y
	当前文件同原始文件相同,但是他们和新文件不同.由于用户并没有
	修改文件,因此新文件可能包含最新的bug修正,所以安装新文件.

	x y x
	新文件同原始文件相同,安装新文件.

	x y z
	三个文件都不同.安装新文件,但加上,pacnew的后缀,警示用户.
	用户必须自己将必要的改变加入原始文件.

##配置

查看"pacman.conf(5)"以获得更多关于运用pacman.conf配置pacman的信息.

##参见

pacman.conf[5] makepkg[8] libalpm[3]

登录pacman网址(http://www.archlinux.org/pacman/)获得pacman以及相关工具
的最新信息.

##BUGS

BUGS？开玩笑！这个软件没有一丝漏洞.如果我们不小心错了的话,

发送邮件至 pacman-dev@archlinux.org, 并附上详细信息.
